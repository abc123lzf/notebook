---
title: Java面向对象基本语法
date: 2017-11-25 16:15:05
tags: CSDN迁移
---
 版权声明：尊重原创，转载请注明出处 [ https://blog.csdn.net/abc123lzf/article/details/78507505]( https://blog.csdn.net/abc123lzf/article/details/78507505)   
  **1、类**   
 Java中定义类的简单语法如下：

 
```
[修饰符] class 类名
{
    零个到多个构造器定义
    零个到多个成员变量
    零个到多个方法
}
```
 成员变量用于定义该类或该类的实例所包含的状态数据，方法则用于定义该类或该类的实例的行为特征或者功能实现。构造器用于构造该类的实例，JAVA语言通过new关键字来调用构造器，从而返回该类的实例。

 Java中类的继承通过extends实现。子类继承父类的语法如下：

 
```
[修饰符]class SubClass extends SuperClass
{
    //类定义部分
}
```
 如果子类继承了父类，子类包含与父类同名方法的现象称为方法的重写。   
 例如下面定义weapeon类的子类AK47

 
```
public class weapeon
{
    public double weight;
    public int reload;
    public void shot()
    {
        System.out.println("突突突");
    }
}
public class AK47 extends weapeon
{
    public void shot()   //方法的重写
    {
        System.out.println("biubiu");
    }
    public static void main(String[] args)
    {
        AK47 one = new AK47();
        AK47.shot();   //将输出biubiu
    }
}
```
 Java中允许同一个类中定义多个同名方法，只要形参列表不同即可。如果一个类中包含了两个或两个以上方法名相同，但形参列表不同，则被称为方法重载。   
 例如:

 
```
public class testClass
{
    public void test()
    {
        System.out.println("无参数");
    }
    public void test(String msg)
    {
        System.out.println(msg);
    }
    public static void main(String[] args)
    {
        testClass one = new testClass();
        one.test();
        one.test("Hello");
    }
}
```
 如果需要在子类方法中调用父类被覆盖的实例方法，则可使用super限定来调用父类被覆盖的实例方法，例如super.say(); 。super不能出现在static修饰的方法中。

 **2、方法**   
 定义方法的简单语法为：

 
```
[修饰符] 方法返回值类型 方法名(形参列表)
{
    //由零条到多条可执行性语句组成的方法体
}
```
 修饰符可以省略，也可以是public、protected、private、static、final、abstract，其中public、protected、private三个最多只能出现其中一个，abstract和final最多只能出现其中一个，它们可以和static组合起来修饰方法。

 返回值类型可以是JAVA语言允许的任何数据类型，包括基本类型和引用类型；如果声明了方法返回值类型，则方法体内必须要有个有效的return语句，该语句返回一个变量或者表达式，这个变量或表达式必须和此次声明的类型匹配。

 方法名的命名规则与成员变量的命名规则基本相同。

 形参列表用于定义该方法可以接受的参数，形参列表有零组到多组“参数类型 形参名”组合而成，多组参数之间用逗号隔开。一旦定义该方法指定了形参列表，则必须在调用该方法时传入对应的参数值。

 **3、构造器**   
 定义构造器的简单语法如下：

 
```
[修饰符] 构造器名(形参列表)
{
    //零条或多条语句
}
```
 构造器是一种特殊的方法。创建对象的基本途径是构造器，通过new关键字来调用某个类的构造器即可创建该类的实例。   
 修饰符：可以省略，也可以是public、protected、private其中之一。   
 构造器名：构造器名必须和类名相同。   
 形参列表：同方法。

 Java的子类不能获得父类的构造器。

 例：创造一个Person类

 
```
class Person
{
    private String name;
    private int age;
    //定义一个构造器
    public setPersonInf(String name,int age)
    {
        this.name = name;
        this.age = age;
    }
    //定义一个方法
    public void say(String content)
    {
        System.out.println(content);
    }
}
```
 其中，this关键字总是指向调用该方法的对象，this的最大作用就是让类中的一个方法，访问该类里的另一个方法或实例变量。static修饰的方法不能使用this引用。

 创建一个对象后，如果访问权限允许，类里定义的方法和成员变量都可以通过类或实例来调用。类或实例访问方法或成员变量的语法是：类.类变量或方法，或者实例.实例变量或方法。

 **4、接口（interface）**   
 接口定义的基本语法：

 
```
[修饰符] interface 接口名 extends 父接口1，父接口2，...
{
    //零到多个常量定义...
    //零到多个抽象方法定义...
    //零到多个内部类、接口、枚举定义...
    //零到多个默认方法或者类方法定义...
}
```
 接口里定义的是多个类共同的公共行为规范。

 修饰符可以是public或者省略，如果省略，则默认采用包权限访问控制符，即在相同包结构下才可以访问该接口。   
 在命名上与类名采用相同规则，但根据习惯，首字母大写，由多个有意义的单词连缀而成。   
 一个接口可以有多个直接父接口，但只能继承接口不可继承类。

 接口的主要作用有：   
 （1）定义变量，也可以用于强制类型转换。   
 （2）调用接口中定义的常量。   
 （3）被其它类实现。

 类实现接口的语法如下:

 
```
[修饰符]class 类名 extends 父类 implements 接口1、接口2...
{
    //类体部分
}
```
 **5、初始化块**   
 与构造器作用类似，初始化块可以对Java对象进行初始化操作。   
 初始化块的基本语法如下：

 
```
[修饰符]
{
    //可以包含任何可执行性语句
}
```
 初始化块的修饰符只能是static，static修饰的初始化块称为静态初始化块。静态初始化块不能访问非静态成员。

 当创建Java对象时，都需要先执行最顶层父类的初始化块、构造器，然后再执行其父类的初始化块、构造器… ，最后再执行该类的初始化块、构造器。从某种程度上来看，初始化块是构造器的补充。

 **6、final关键字**   
 final关键字可用于修饰类、变量和方法，用于表示它修饰的类、方法和变量不可改变。final修饰的变量一旦获得初始值，该final变量的值就不可被重新赋值。   
 final修饰的类变量、实例变量能指定初始值的地方如下：   
 （1）类变量：必须在静态初始化块中指定初始值或者声明该类变量时指定初始值，而且只能在两个地方的其中之一指定。   
 （2）实例变量：必须在非静态初始化块、声明该实例变量或构造器中指定初始值，而且只能在三个地方其中之一指定。

 当final修饰引用类型变量时，final只能保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但是这个对象完全可以改变。

 当final修饰方法时，代表该方法不可被重写。如果出于一些原因不希望子类重写父类的某个方法，则可以使用final修饰该方法。final修饰的方法可以重载。

 当final修饰类时，该类不可有子类。

 **7、abstract关键字**   
 抽象方法和抽象类必须使用abstract修饰符来定义，有抽象方法的类只能被定义为抽象类，抽象类里可以没有抽象方法。   
 Java中抽象方法和抽象类（abstract修饰的方法和类）的规则为：   
 （1）抽象方法不能有方法体。其修饰的方法必须被其子类重写才有意义，因此abstract修饰的方法不能定义为private访问权限。   
 （2）抽象类不能实例化，无法使用new关键字来调用抽象类的构造器创建抽象类的实例。抽象类主要是用于被其子类调用。   
 （3）含有抽象方法的类只能被定义为抽象类。

 参考书籍：《JAVA疯狂讲义（第3版）》

   
  